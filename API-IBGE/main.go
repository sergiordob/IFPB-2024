/*INSTITUTO FEDERAL DA PARAIBA - IFPB
UNIDADE ACADEMICA DE INFORMACAO E COMUNICACAO
MESTRADO PROFISSIONAL EM TECNOLOGIA DA INFORMACAO

DISCIPLINA: BANCO DE DADOS
PROFESSORES: DAMIRES E DIEGO

ALUNO: SERGIO RICARDO DE OLIVEIRA BRANDAO

ATIVIDADE 02, QUESITO 02: CRIE UM SCRIPT PARA CONSUMIR DADOS DA API DO IBGE - https://servicodados.ibge.gov.br/api/docs/localidades#api-Municipios-estadosUFMunicipiosGet - PARA LISTAR OS NOMES DAS CIDADES DE UM ESTADO ESPECIFICO.

SOLUCAO IMPLEMENTADA EM GOLANG*/

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

/*Em Golang, os JSONs são desserializados por meio de structs. Como o exercicio requisita apenas o nome da cidade, a struct abaixo contém apenas o nome da cidade, mas caso fosse pedido o retorno do JSON inteiro fornecido pela API, a struct poderia conter todos os atributos do JSON. Para fazer essa tradução JSON-Struct, podemos fazer uso da ferramenta https://mholt.github.io/json-to-go/ . Nela, colamos o JSON retornado pela API e recebemos uma struct correspondente.

type AutoGenerated []struct {
	ID           int    `json:"id"`
	Nome         string `json:"nome"`
	Microrregiao struct {
		ID          int    `json:"id"`
		Nome        string `json:"nome"`
		Mesorregiao struct {
			ID   int    `json:"id"`
			Nome string `json:"nome"`
			Uf   struct {
				ID     int    `json:"id"`
				Sigla  string `json:"sigla"`
				Nome   string `json:"nome"`
				Regiao struct {
					ID    int    `json:"id"`
					Sigla string `json:"sigla"`
					Nome  string `json:"nome"`
				} `json:"regiao"`
			} `json:"UF"`
		} `json:"mesorregiao"`
	} `json:"microrregiao"`
	RegiaoImediata struct {
		ID                  int    `json:"id"`
		Nome                string `json:"nome"`
		RegiaoIntermediaria struct {
			ID   int    `json:"id"`
			Nome string `json:"nome"`
			Uf   struct {
				ID     int    `json:"id"`
				Sigla  string `json:"sigla"`
				Nome   string `json:"nome"`
				Regiao struct {
					ID    int    `json:"id"`
					Sigla string `json:"sigla"`
					Nome  string `json:"nome"`
				} `json:"regiao"`
			} `json:"UF"`
		} `json:"regiao-intermediaria"`
	} `json:"regiao-imediata"`
}
*/

type Cidade struct {
	Nome string `json:"nome"`
}

func GetCidadesPorEstado(ID string) ([]byte, error) {
	respostaHTTP, err := http.Get("https://servicodados.ibge.gov.br/api/v1/localidades/estados/" + ID + "/municipios")
	if err != nil {
		return nil, err
	}
	defer respostaHTTP.Body.Close() //Garante que o corpo da resposta HTTP eh fechado.

	body, err := io.ReadAll(respostaHTTP.Body) //Retorna o JSON serializado como um slice (array) de bytes: A resposta HTTP eh do tipo io.ReadCloser, uma interface que contem duas outras interfaces: io.Reader e io.Closer. Nesse sentido, eh possivel usar ReadAll para ler o corpo da resposta HTTP e o armazenar em um slice (array) de bytes.
	if err != nil {
		return nil, err
	}

	return body, nil //Retorna um JSON serializado como um slice (array) de bytes.
}

func main() {
	body, err := GetCidadesPorEstado("25") //A documentação da API informa que ela foi implementada a partir de códigos que refletem os estados. No caso em destaque, estamos usando o ID = 25, que corresponde ao estado da Paraiba. Dessa forma, teremos a listagem de todas as cidades do estado.

	if err != nil {
		fmt.Println("Erro ao obter cidades:", err)
		return // Retorne se houver um erro
	}

	var cidades []Cidade                 //cidades precisa ser um  slice (array) de structs
	err = json.Unmarshal(body, &cidades) //Armazena o JSON, na forma de slice (array) de bytes, na struct (desserializa), para que seja possivel processar as informacoes e imprimir elas de forma adequada
	if err != nil {
		fmt.Println("Erro na deserialização do JSON:", err)
		return
	}

	for i := 0; i < len(cidades); i++ {
		fmt.Printf("Cidade %d: %s\n", i, cidades[i].Nome) // Imprima o nome da cidade
	}
}
